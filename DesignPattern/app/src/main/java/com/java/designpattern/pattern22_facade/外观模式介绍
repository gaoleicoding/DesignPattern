迪米特法则(最少知识原则)
一个软件实体应当尽可能少的与其他实体发生相互作用。
外观模式核心
为子系统提供统一的入口,封装子系统的复杂性,便于客户端调用。

外观模式的优缺点及使用场景
优点：

它对客户端屏蔽了子系统的组件（可以直接调用外观模式），减少了系统的耦合度，使客户端所需要调用的所处理的类的数目减少，全让外观模式，小二去解决。简化客户端代码！
它实现了系统与客户端之间的松耦合关系，子系统的修改不会影响客户端代码，只要修改外观模式就好。
一个子系统的修改该对其它子系统没有任何影响，而且子系统内部变化也不会影响到外观模式。
缺点：

并不能限制客户端直接调用子系统，如果客户端对子系统类做太多限制则减少了可变形和灵活性。
如果设计不当，增加新的子系统就可能修改外观类的源代码，不符合开闭原则。
 

使用场景：

1、当客户端需要调用一系列复杂子系统时候，可以提供一个简单入口的时候使用外观模式。

2、客户端与子系统有很大的耦合性，使用外观模式可以充分解耦。

3、再层次化结构中可以使用外观模式的定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，减低层与层之间的耦合。
开发中常见的场景
频率很高。哪里都会遇到。各种技术和框架,都有外观模式的使用。

何时使用外观模式
再设计初期阶段,应该有意识的将不同的两个层分离,比如经典的三层架构,就需要考虑在数据访问层和业务逻辑层、业务逻辑层和表示层的层与层之间建立外观Facade，这样可以为复杂的子系统提供一个简单的接口，使得耦合大大降低。
再开发阶段，子系统往往因为不断的重构演化而变得越来越复杂，大多数的模式使用时也都会产生很多很小的类，这本是好事，但也给外部调用它们的用户程序带来了使用上的困难，增加外观Facade可以提供一个简单的接口，减少它们之间的依赖。
在维护一个遗留的大型系统时，可能这个系统已经非常难以维护和扩展了，但因为它包含非常重要的功能，新的需求开发必须依赖于它。此时用外观模式Facade也是非常合适的。你可以为新系统开发一个外观Facade类，来提供设计粗糙或高度复杂的遗留代码的比较清晰简单的接口，让新系统于Facade对象交互，Facade于遗留代码交互所有复杂的工作。
